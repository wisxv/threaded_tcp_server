# Многопоточный TCP сервер

### Описание

Многопоточный TCP сервер. Количество потоков задается при запуске и поддерживается с помощью семафора. При запуске сервера задаются: кол-во потоков, директория для карантина (при необходимости создается).
### Пример запуска

```bash
# запуск со значениями по умолчанию: ./quarantine и 4
python3 server.py
# указать желаемые значения
python3 server.py -q <.>/директория/карантина -t 4
```
### Поддерживаемые запросы

- `CheckLocalFile` - проверить наличие сигнатуры в локальном файле на сервере и вернуть смещения, где она встречалась.
  - Параметры: путь до файла, сигнатура.

- `QuarantineLocalFile` - переместить файл в директорию карантина.
  - Параметры: путь до файла.

### Структура JSON запроса
В задании допущена логическая ошибка в структуре запросов:
Предлагается передавать запросы в формате json, где `command1` - ключ.

- имеется в виду замена на имя команды? → нет смысла в значении  `“name”`: ключ уже содержит название команды
- имеется в виду передача нескольких команд в одном запросе? → есть необходимость нумерации ключей параметров, 
  но ее нет в задании

Значит в предложенной структуре допущена логическая ошибка. 
Наиболее вероятно, что имелась в виду следующая структура json для запроса:
```json
{ "name": "<command_name>",
  "params": { "<param_1>": "<param_1_value>",
              "<param_x>": "<param_x_value>"}}
```

### Обработка запросов
Реализован буфер, в который помещаются данные (например, если json слишком длинный). 
Ограничен 'магическим числом' = 1 Мб для защиты от переполнения

### Примечания в коде
Участки кода с комментариями вида `note_<число>` объяснены здесь:

- **note_1**:
В задании не сказано, когда следует завершать соединение и выполнение потоков.
Поскольку не ожидаются дополнительные команды 
и есть акцент на многопоточности с фиксированным кол-вом потоков,
завершение соединения выполняется после выполнения команды,
чтобы освободить поток для возможности подключения нового клиента.


- **note_2**
Без тайм-аута, блокирующий accept метод мог бы задерживать завершение сервера, 
так как не будет возвращаться до тех пор, пока не будет установлено соединение или не произойдёт ошибка. 
Тайм-аут позволяет выходить из блока accept, чтобы проверить флаг завершения shutdown_event.
Не нарушит способность принимать соединения.


- **note_3**: Применяется только в основном потоке, не влияет на обработку клиентов:
  - Основной поток сервера начинает работу, запускает серверный сокет и переходит в состояние ожидания 
  - При получении сигнала SIGINT (например, при нажатии Ctrl-C), основной поток отключается от паузы, 
   устанавливает флаг завершения и завершает работу


- **note_4**:
Ожидание позволяет корректно завершить дочерние процессы, 
но зависит от времени их выполнения и ошибок в них


- **note_5**:
Используется глобальная переменная quarantine_directory 
т.к. это самый простой способ передать ее в данную функцию. 
Иначе пришлось бы усложнять класс сервера несвойственными для него задачами.

# Однопоточный tcp клиент
Примеры запуска:
```bash
# помощь по суб-командам, аргументам, их значениям
python3 client.py -h

# проверка сигнатуры в файле
python3 client.py check-file -f ./test.txt -s 0a

# переместить в директорию карантина
python3 client.py quarantine-file -f ./test.txt
```

# Формулировка задания
Необходимо реализовать многопоточный TCP-сервер и однопоточный консольный клиент
для отправки запросов серверу.

Запросы передаются в формате JSON и имеют вид:
```json
{
  "command1":"name",
  "params": {
    "param1":"value1"
  }
}
```

Сервер должен обрабатывать запросы двух видов:

а) CheckLocalFile - проверить указанный в запросе файл на сигнатуру (путь к файлу, и
сигнатура передается в параметрах запроса). В ответе сервер должен привести список смещений
найденных сигнатур. Сигнатура представлена в виде набора байт длиной до 1Кб.

б) QuarantineLocalFile – переместить указанный файл в карантин (в специальный каталог,
указанный в опциях запуска сервера).

На старте сервера задаются: количество потоков в пуле обработки запросов;
На старте клиента задаются: команда и ее параметры;

Приложение завершает выполнение: при получении сигнал пользователя о завершении
SIGINT (Ctrl+C);

Язык реализации: На выбор Python / С / С++ / Rust
Формат представления результатов: Архив с исходным кодом (без бинарных файлов)
и инструкция по сборке